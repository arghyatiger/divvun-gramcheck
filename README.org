#+TITLE: divvun-gramcheck
#+STARTUP: showall

#+CAPTION: Build Status
[[https://travis-ci.org/divvun/divvun-gramcheck][https://travis-ci.org/divvun/divvun-gramcheck.svg]]

#+CAPTION: Coverity static analysis
[[https://scan.coverity.com/projects/divvun-divvun-gramcheck][https://scan.coverity.com/projects/13737/badge.svg]]

* Description

This repository contains three main programs:

The =divvun-gramcheck= program, opens a grammar checker pipeline XML
specification and lets you run grammar checking on strings. It can
also open zip files containing the XML and all required language data.
There is a C++ library =libdivvun= (=divvun/checker.hpp=) which allows
for the same features.


The =divvun-suggest= program does FST lookup on forms specified as
Constraint Grammar format readings, and looks up error-tags in an XML
file with human-readable messages. It is meant to be used as a late
stage of a grammar checker pipeline.

The main output format of =divvun-suggest= is JSON, although it can
also simply annotate readings in CG stream format.


The =divvun-cgspell= program spells unknown word forms from Constraint
Grammar format readings, adding them as new readings.


The =divvun-blanktag= program takes an FST as argument, reads CG input
and uses the FST to add readings to cohorts that match on the wordform
surrounded by the preceding and following blanks. Use cases include
adding error tags that are dependent on spaces before/after, or
tagging the first word after a linebreak or certain formatting.


There are also some helper programs for validating XML
(=divvun-validate-suggest=, =divvun-validate-pipespec=,
=divvun-gen-xmlschemas=) and for generating shell scripts from
pipeline specifications (=divvun-gen-sh=).

* Simple build from git on Mac

There is a script that will download prerequisites and compile and
install for Mac; just run:
#+BEGIN_SRC sh
curl https://raw.githubusercontent.com/divvun/divvun-gramcheck/master/scripts/mac-build | bash
#+END_SRC

It does not (yet) enable =divvun-checker=, since that has yet more
dependencies. It assumes you've got =xmllint= installed.

* Prerequisites

** For just =divvun-suggest=

- gcc >=5.0.0 with libstdc++-5-dev (or similarly recent version of
  clang, with full C++11 support)
- libxml2-utils (just for xmllint)
- libhfst >=3.12.2
- libpugixml >=1.7.2 (optional)

Tested with gcc-5.2.0, gcc-5.3.1 and clang-703.0.29. On Mac OS X, the
newest XCode includes a modern C++ compiler.

If you can't easily install libpugixml, you can run
[[file:scripts/get-pugixml-and-build][scripts/get-pugixml-and-build]] which will download libpugixml into this
directory, build that (with cmake) and configure this program to use
that library. Alternatively, you can run ./configure with
=--disable-xml= if you don't care about human-readable error messages.

** For both =divvun-suggest= and =divvun-gramcheck=

- gcc >=5.0.0 with libstdc++-5-dev (or similarly recent version of
  clang, with full C++11 support)
- libxml2-utils (just for xmllint)
- libhfst >=3.12.2
- libpugixml >=1.7.2
- libcg3-dev >=1.1.2.12327
- libarchive >=3.2.2-2

Tested with gcc-5.2.0, gcc-5.3.1 and clang-703.0.29. On Mac OS X, the
newest XCode includes a modern C++ compiler.

If you can't easily install libpugixml, you can run
[[file:scripts/get-pugixml-and-build][scripts/get-pugixml-and-build]] which will download libpugixml into this
directory, build that (with cmake) and configure this program to use
that library.

Now when building, pass =--enable-checker= to configure.

** If you also want =divvun-cgspell=

- hfst-ospell-dev >=0.4.5 (compiled with either libxml or tinyxml)

You can pass =--enable-cgspell= to =./configure= if you would like to
get an error if any of the =divvun-cgspell= dependencies are missing.

* Building

#+BEGIN_SRC sh
./autogen.sh
./configure --enable-checker  # or just "./configure" if you don't need divvun-gramcheck
make
make install # with sudo if you didn't specify a --prefix to ./configure
#+END_SRC


On OS X, you may have to do this:

#+BEGIN_SRC sh
sudo port install pugixml
export CC=clang CXX=clang++ "CXXFLAGS=-std=gnu++11 -stdlib=libc++"
./autogen.sh
./configure  LDFLAGS=-L/opt/local/lib --enable-checker
make
make install # with sudo if you didn't specify a --prefix to ./configure
#+END_SRC

* Usage

** =divvun-suggest=

=divvun-suggest= takes two arguments: a generator FST (in HFST
optimised lookup format), and an error message XML file (see [[https://gtsvn.uit.no/langtech/trunk/langs/sme/tools/grammarcheckers/errors.xml][the one
for Northern Saami]] for an example), with input/output as stdin and
stdout:

#+BEGIN_SRC sh
src/divvun-suggest --json generator-gt-norm.hfstol errors.xml < input > output
#+END_SRC


More typically, it'll be in a pipeline after various runs of =vislcg3=:

#+BEGIN_SRC sh
echo words go here | hfst-tokenise --giella-cg tokeniser.pmhfst | â€¦ | vislcg3 â€¦ \
  | divvun-suggest --json generator-gt-norm.hfstol errors.xml
#+END_SRC

** =divvun-cgspell=

=divvun-cgspell= takes one file argument: a zhfst speller archive as
used by [[https://github.com/hfst/hfst-ospell/][hfst-ospell]]. There are some options for limiting suggestions
too, see =--help=. You'll probably want to use =--limit=.

#+BEGIN_SRC sh
src/divvun-cgspell --limit 5 se.zhfst < input > output
#+END_SRC


More typically, it'll be in a pipeline before/after various runs of =vislcg3=:

#+BEGIN_SRC sh
echo words go here | hfst-tokenise --giella-cg tokeniser.pmhfst | â€¦ | vislcg3 â€¦ \
  | src/divvun-cgspell --limit 5 se.zhfst | vislcg3 â€¦
#+END_SRC

You can also use it with unzipped, plain analyser and error model, e.g.

#+BEGIN_SRC sh
src/divvun-cgspell --limit 5 -l analyser.hfstol -m errmodel.hfst < input > output
#+END_SRC

** =divvun-checker=

=divvun-checker= is an example command-line interface to =libdivvun=.
You can use it to test a =pipespec.xml= or a zip archive containing
both the pipespec and langauge data, e.g.

#+BEGIN_SRC sh
$ divvun-checker -a sme.zhfst
Please specify a pipeline variant with the -n/--variant option. Available variants in archive:
smegram
smepunct

$ echo ballat oÄ‘Ä‘a dieÄ‘uiguin | src/divvun-checker -a sme.zhfst -n smegram
{"errs":[["dieÄ‘uiguin",12,22,"msyn-valency-loc-com","Wrong valency or something",["diehtukorrekt"]]],"text":"ballat oÄ‘Ä‘a dieÄ‘uiguin"}

$ divvun-checker -s pipespec.xml
Please specify a pipeline variant with the -n/--variant option. Available variants in pipespec:
smegram
smepunct

$ echo ballat oÄ‘Ä‘a dieÄ‘uiguin | src/divvun-checker -s pipespec.xml -n smegram
{"errs":[["dieÄ‘uiguin",12,22,"msyn-valency-loc-com","Wrong valency or something",["diehtukorrekt"]]],"text":"ballat oÄ‘Ä‘a dieÄ‘uiguin"}
#+END_SRC

When using the =-s/--spec pipespec.xml= option, relative paths in the
pipespec are relative to the current directory.

See the =test/= folder for an example of zipped archives.

See the [[file:examples/using-checker-lib-from-cpp][examples folder]] for how to link into divvun-gramcheck and use
it as a library, getting out either the JSON-formatted list of errors,
or a simple [[file:src/checkertypes.hpp::struct%20Err%20{][data structure]] that contains the same information as the
JSON. The next section describes the JSON format.


* JSON format
The JSON output of =divvun-suggest= is meant to be sent to a client
such as [[https://github.com/divvun/divvun-webdemo]]. The current format
is:

: {errs:[[str:string, beg:number, end:number, typ:string, exp:string, [rep:string]]], text:string}

The string =text= is the input, for sanity-checking.

The array-of-arrays =errs= has one array per error. Within each
error-array, =beg/end= are offsets in =text=, =typ= is the (internal)
error type, =exp= is the human-readable explanation, and each =rep= is
a possible suggestion for replacement of the text between =beg/end= in
=text=.

The index =beg= is inclusive, =end= exclusive, and both indices are
based on a UTF-16 encoding (which is what JavaScript uses, so e.g. the
emoji "ðŸ‡³ðŸ‡´" will increase the index of the following errors by 4).

Example output:

#+BEGIN_SRC js
  {
    "errs": [
      [
        "badjel",
        37,
        43,
        "lex-bokte-not-badjel",
        "\"bokte\" iige \"badjel\"",
        [
          "bokte"
        ]
      ]
    ],
    "text": "ðŸ‡³ðŸ‡´sÃ¡ddejuvvot bÃ¡hpirat interneahta badjel.\n"
  }
#+END_SRC

* Pipespec XML

The =divvun-checker= program and =libdivvun= (=divvun/checker.hpp=)
API has an XML format for specifying what programs go into the checker
pipelines, and metadata about the pipelines.

A =pipespec.xml= defines a set of grammar checker (or really any text
processing) pipelines.

There is a main language for each pipespec, but individual pipelines
may override with variants.

Each pipeline may define certain a set of mutually exclusive (radio
button) preferences, and if there's a =<suggest>= element referring to
an =errors.xml= file in the pipeline, error tags from that may be used
to populate UI's for hiding certain errors.



** Mapping from XML preferences to UI

The mapping from preferences in the XML to a user interface should be
possible to do automatically, so the UI writer doesn't have to know
anything about what preferences the pipespec defines, but can just ask
the API for a list of preferences.

Preferences in the UI are either checkboxes [X] or radio buttons (*).


We might for example get the following preferences UI:
: (*) Nordsamisk, Sverige
: ( ) Nordsamisk, Noreg
: â€¦
: [X] Punctuation
:     (*) punktum som tusenskilje
:     ( ) mellomrom som tusenskilje
: [-] Grammar errors
:     [X] ekteordsfeil
:     [ ] syntaksfeil


Here, the available languages are scraped from the pipespec.xml
using =//pipeline/@language=.

A language is selected, so we create a Main Category of error types from
: pipespec.xml //[@language=Sverige|@language=""]/prefs/@type
: pipespec.xml //pipeline[@language=Sverige|@language=""]/@type
: errors.xml   //default/@type
: errors.xml   //error/@type

in this case giving the set { Punctuation, Grammar errors }.

One Main Category type is Punctuation; the radio buttons under
this main category are those defined in
: pipespec.xml //prefs[@type="Punctuation"]

The other Main Category type is Grammar errors; maybe we didn't have anything
in
: pipespec.xml //prefs[@type="Grammar errors"]
but there are checkboxes for errors that we can hide in
: errors.xml //defaults/default/title

It should be possible for the UI to hide which underlying
=<pipeline>='s are chosen, and only show the preferences (picking a
pipeline based on preferences). But there is an edge case: Say the
pipe named smegram_SE with language sme_SE and main type "Grammar
errors" has a
: pref[@type="Punctuation"]
and there's another pipe named smepunct with main type "Punctuation".
Now, assuming we select the language sme_SE, we'll never use smepunct,
since smegram defines error types that smepunct doesn't, but not the
other way around. Hopefully this is not a problem in practice.

* Troubleshooting

If you get
: terminate called after throwing an instance of 'std::regex_error'
:   what():  regex_error
or
: util.hpp:36:19: fatal error: codecvt: No such file or directory
:  #include <codecvt>
:                    ^
: compilation terminated.
then your C++ compiler is too old. See [[./README.org::*Prerequisites][Prerequisites]].


If you get
: configure: error: 'g++  -std=c++11 -Wall -I/usr/include/hfst/ @GLIB_CFLAGS@  -I/usr/include/ ' does not accept ISO C++11
then you may be at the receiving end of
https://github.com/hfst/hfst/issues/366. A workaround is to edit
=/usr/lib64/pkgconfig/hfst.pc= and simply delete the string
=@GLIB_CFLAGS@=.


* Progress [44/49]

=divvun-suggest= should:

- [X] read cg format
- [X] load errors.xml
- [X] load an hfstol bin
- [X] generate forms from CG-specified analyses
- [X] only generate forms if analyses have a certain tag (and don't send that tag to generator)
- [ ] possibly load some additional specification for how to extract forms from CG-format?
- [X] optionally output as JSON
- [X] handle superblanks
- [X] 4+-byte UTF-8 input
- [X] default/fallback values for ids and regexes of ids in errors.xml
- [X] flush on seeing <STREAMCMD:FLUSH>
- [X] skip @FLAGDIACRITICS@ in generator output (is there a better way than [[file:src/suggest.cpp::if(symbol.size()>0%20&&%20symbol%5B0%5D!='@')%20{][excluding symbols starting with @]]?)
- [X] deal with subreadings: http://giellatekno.uit.no/bugzilla/show_bug.cgi?id=2317#c5
- [X] input format needs to show where we have (and don't have) blanks
- [X] deal with the new blank format given by hfst-tokenise (and remove old blank hacks)
- [ ] handle [[*sketch for alternative suggestions on the same word][alternative suggestions on the same word]]
- [ ] handle &DELETE nicely (UI also: sihko sÃ¡ni = slett ordet)

=divvun-checker= should:

- [X] use run(stringstream, ostream) on hfst-tokenize as lib
- [X] use run(stringstream, ostream) on cg-mwesplit as lib
- [X] use run(stringstream, ostream) on vislcg3-grammar as lib
- [X] use run(stringstream, ostream) on divvun-suggest as lib
- [X] use upstream hfst ([[https://github.com/hfst/hfst/pull/352][merged]])
- [X] use upstream vislcg3, currently [[https://github.com/TinoDidriksen/cg3/issues/1][waiting on a merge]] (updated: [[https://github.com/unhammer/vislcg3/tree/StreamApplicator-merge-r12311][StreamApplicator-merge-r12311]])
- [X] read xml pipeline specification and load data based on that
- [X] allow multiple pipelines in spec
- [ ] allow variants of one pipeline in spec (e.g. turn off section 1/2/3/â€¦ of grammarchecker.cg3)
- [X] allow similar metadata to hfst-ospell (see [[https://github.com/hfst/hfst-ospell/blob/master/tests/basic_test.xml][tests/basic_test.xml]])
- [X] load PipeSpec from char buffer
- [X] load TokenizerCmd from char buffer
- [X] load MweSplitCmd from char buffer
- [X] load CGCmd from char buffer
- [X] load SuggestCmd from char buffer (HFST needs an =HfstOlInputStream(std::istream&)=)
- [X] read zip-archive like zhfst
- [X] get some API documentation
- [X] return both string and real datastructure (latter only if Suggest as last cmd)
- [X] hide implementation, make an example project using the API
- [X] travis (both Mac and Ubuntu)
- [X] link to vislcg3 without needing the source (vislcg3 has to make the functions we use available from cg3.h)

=divvun-cgspell= should:

- [X] load a zhfst bin
- [X] optionally load errmodel.hfst and acceptor.hfst instead of zhfst
- [ ] Read a word per line and spell with CG output (do we still need this?)
- [X] Read CG input and spell unknown words by adding them as new readings
- [X] Read CG input and spell all words by adding them as new readings
- [X] do NUL-flushing, outputting <STREAMCMD:FLUSH>
- [X] have a timeout on generating suggestions (shouldn't use more than 0.5s per sentence?)

=divvun-blanktag= should:

- [X] load an hfst bin
- [X] Read CG input and analyse sequences of blank-wordform-blank
- [X] Put output tag of matches on each reading under the matched wf
- [X] Be usable from checker, checker-lib, apy etc., like suggest and cgspell


** TODO alternative suggestions on the same word

When we might have different error types, put the error tag on the
&SUGGEST reading:

#+begin_src cg
  "<dego>"
          "dego" CS <W:0> @CNP ID:11
  :
  "<lÃ¡vvomuorran>"
          "lÃ¡vvomuorra" N Sem/Dummytag Ess <W:0> @COMP-CS< &syn-not-dego R:DELETE1:11
          "lÃ¡vvomuorra" N Sem/Dummytag Nom <W:0> @COMP-CS< &syn-dego-nom &SUGGEST
  "<.>"
#+end_src

Here, /lÃ¡vvomuorran/ is the (only) word carrying error tags. A reading
on this word contains all info needed to generate the suggestion.

The reading with the &SUGGEST tag thus needs to have the error tag on
the same reading (otherwise we can't know which error tag-reading goes
with which DELETE/SUGGEST-reading).

-----

Do we ever want &SUGGEST on the same error instance (underline)
crossing at least two cohorts? In that case, we need e.g. R:RIGHT on
the rightmost word to be included in one and the same error instance:

#+begin_src cg
  "<grÃ¸nt>"
          "grÃ¸n" A Pst Sg Ind Neut ID:41
          "grÃ¸n" A Pst Sg Ind Masc &SUGGEST &sÃ¥-veldig-feil-masc R:RIGHT:42
          "grÃ¸n" A Pst Sg Def &SUGGEST &sÃ¥-veldig-feil-def
  :
  "<osten>"
          "ost" N Masc Sg Def ID:42
          "ost" N Masc Sg Ind &SUGGEST &sÃ¥-veldig-feil-masc
  "<.>"
#+end_src
Here, on seeing R:RIGHT, we know we need to underline until the next
word with the same error tag &sÃ¥-veldig-feil-masc, giving the
suggestion "grÃ¸n ost". Since a different suggestion was covered by
that underline, we have to expand the underline for that word as well
(giving "grÃ¸ne osten"), since UI's can't typically handle overlapping
underlines.
