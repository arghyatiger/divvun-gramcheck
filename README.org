#+TITLE: divvun-gramcheck
#+STARTUP: showall

#+CAPTION: Build Status
[[https://travis-ci.org/divvun/divvun-gramcheck][https://travis-ci.org/divvun/divvun-gramcheck.svg]]

* Description

This repository contains two programs:

The =divvun-gramcheck= program, and =checker= library, opens a grammar
checker pipeline XML specification and lets you run grammar checking
on strings. It can also open zip files containing the XML and all
required langauge data.


The =divvun-suggest= program, and =suggest= library, does FST lookup
on forms specified as Constraint Grammar format readings, and looks up
error-tags in an XML file with human-readable messages. It is meant to
be used as a late stage of a grammar checker pipeline.

The main output format is JSON, although it can also simply annotate
readings in CG stream format.

* Prerequisites

** For just =divvun-suggest=

- gcc >=5.0.0 with libstdc++-5-dev (or similarly recent version of
  clang, with full C++11 support)
- libhfst >=3.12.2
- libpugixml >=1.7.2 (optional)

Tested with gcc-5.2.0, gcc-5.3.1 and clang-703.0.29. On Mac OS X, the
newest XCode includes a modern C++ compiler.

If you can't easily install libpugixml, you can run
[[file:scripts/get-pugixml-and-build][scripts/get-pugixml-and-build]] which will download libpugixml into this
directory, build that (with cmake) and configure this program to use
that library. Alternatively, you can run ./configure with
--disable-xml if you don't care about human-readable error messages.

** For both =divvun-suggest= and =divvun-gramcheck=

- gcc >=5.0.0 with libstdc++-5-dev (or similarly recent version of
  clang, with full C++11 support)
- libhfst >=3.12.2
- libpugixml >=1.7.2
- vislcg3, branch StreamApplicator-merge-r12311
- libarchive >=3.2.2-2

Tested with gcc-5.2.0, gcc-5.3.1 and clang-703.0.29. On Mac OS X, the
newest XCode includes a modern C++ compiler.

If you can't easily install libpugixml, you can run
[[file:scripts/get-pugixml-and-build][scripts/get-pugixml-and-build]] which will download libpugixml into this
directory, build that (with cmake) and configure this program to use
that library.

Unfortunately we need our own branch of vislcg3 at the moment. Our makefiles
expect it to be in the folder third-party/cg3.  To fetch and compile the code,
do:

#+BEGIN_SRC sh
git clone -b StreamApplicator-merge-r12311 https://github.com/unhammer/vislcg3 third-party/cg3
cd third-party/cg3
./cmake.sh
make -j3
sudo make install
#+END_SRC

Now when building, pass =--enable-checker= to configure.

* Building

#+BEGIN_SRC sh
./autogen.sh
./configure --enable-checker  # or just "./configure" if you don't need divvun-gramcheck
make
make install # with sudo if you didn't specify a --prefix to ./configure
#+END_SRC


On OS X, you may have to do this:

#+BEGIN_SRC sh
sudo port install pugixml
export CC=clang CXX=clang++ "CXXFLAGS=-std=gnu++11 -stdlib=libc++"
./autogen.sh
./configure  LDFLAGS=-L/opt/local/lib --enable-checker
make
make install # with sudo if you didn't specify a --prefix to ./configure
#+END_SRC

* Usage

=divvun-suggest= takes two arguments: a generator FST (in HFST optimised lookup
format), and an error message XML file (see [[https://gtsvn.uit.no/langtech/trunk/langs/sme/tools/grammarcheckers/errors.xml][the one for Northern Saami]]
for an example), with input/output as stdin and stdout:

#+BEGIN_SRC sh
src/divvun-suggest --json generator-gt-norm.hfstol errors.xml < input > output
#+END_SRC


More typically, it'll be in a pipeline after various runs of =vislcg3=:

#+BEGIN_SRC sh
echo words go here | hfst-tokenise --giella-cg tokeniser.pmhfst | â€¦ | vislcg3 â€¦ \
  | divvun-suggest --json generator-gt-norm.hfstol errors.xml
#+END_SRC



=divvun-checker= is an example command-line interface to
=libdivvun-checker=. You can use it to test a =pipespec.xml= or a zip
archive containing both the pipespec and langauge data, e.g.

#+BEGIN_SRC sh
$ divvun-checker -a sme.zhfst
Please specify a pipeline variant with the -n/--variant option. Available variants in archive:
smegram
smepunct

$ echo ballat oÄ‘Ä‘a dieÄ‘uiguin | src/divvun-checker -a sme.zhfst -n smegram
{"errs":[["dieÄ‘uiguin",12,22,"msyn-valency-loc-com","Wrong valency or something",["diehtukorrekt"]]],"text":"ballat oÄ‘Ä‘a dieÄ‘uiguin"}

$ divvun-checker -s pipespec.xml
Please specify a pipeline variant with the -n/--variant option. Available variants in pipespec:
smegram
smepunct

$ echo ballat oÄ‘Ä‘a dieÄ‘uiguin | src/divvun-checker -s pipespec.xml -n smegram
{"errs":[["dieÄ‘uiguin",12,22,"msyn-valency-loc-com","Wrong valency or something",["diehtukorrekt"]]],"text":"ballat oÄ‘Ä‘a dieÄ‘uiguin"}
#+END_SRC

When using the =-s/--spec pipespec.xml= option, relative paths in the
pipespec are relative to the current directory.

See the =test/= folder for an example of zipped archives.


* JSON format
The JSON output is meant to be sent to a client such as
https://github.com/unhammer/divvun-webdemo. The current format is:

: {errs:[[str:string, beg:number, end:number, typ:string, exp:string, [rep:string]]], text:string}

The string =text= is the input, for sanity-checking.

The array-of-arrays =errs= has one array per error. Within each
error-array, =beg/end= are offsets in =text=, =typ= is the (internal)
error type, =exp= is the human-readable explanation, and each =rep= is
a possible suggestion for replacement of the text between =beg/end= in
=text=.

The index =beg= is inclusive, =end= exclusive, and both indices are
based on a UTF-16 encoding (which is what JavaScript uses, so e.g. the
emoji "ðŸ‡³ðŸ‡´" will increase the index of the following errors by 4).

Example output:

#+BEGIN_SRC js
  {
    "errs": [
      [
        "badjel",
        37,
        43,
        "lex-bokte-not-badjel",
        "\"bokte\" iige \"badjel\"",
        [
          "bokte"
        ]
      ]
    ],
    "text": "ðŸ‡³ðŸ‡´sÃ¡ddejuvvot bÃ¡hpirat interneahta badjel.\n"
  }
#+END_SRC

* Troubleshooting

If you get
: terminate called after throwing an instance of 'std::regex_error'
:   what():  regex_error
or
: util.hpp:36:19: fatal error: codecvt: No such file or directory
:  #include <codecvt>
:                    ^
: compilation terminated.
then your C++ compiler is too old. See [[./README.org::*Prerequisites][Prerequisites]].


* Progress [27/35]

=divvun-suggest= should:

- [X] read cg format
- [X] load errors.xml
- [X] load an hfstol bin
- [X] generate forms from CG-specified analyses
- [X] only generate forms if analyses have a certain tag (and don't send that tag to generator)
- [ ] possibly load some additional specification for how to extract forms from CG-format?
- [X] optionally output as JSON
- [X] handle superblanks
- [X] 4+-byte UTF-8 input
- [X] default/fallback values for ids and regexes of ids in errors.xml
- [X] flush on seeing <STREAMCMD:FLUSH>
- [ ] skip @FLAGDIACRITICS@ in generator output (is there a better way than [[file:src/suggest.cpp::if(symbol.size()>0%20&&%20symbol%5B0%5D!='@')%20{][excluding symbols starting with @]]?)
- [ ] deal with subreadings: http://giellatekno.uit.no/bugzilla/show_bug.cgi?id=2317#c5
- [X] input format needs to show where we have (and don't have) blanks
- [X] deal with the new blank format given by hfst-tokenise (and remove old blank hacks)
- [ ] handle [[*sketch for alternative suggestions on the same word][alternative suggestions on the same word]]
- [ ] handle &DELETE nicely (UI also: sihko sÃ¡ni = slett ordet)

=divvun-checker= should:

- [X] use run(stringstream, ostream) on hfst-tokenize as lib
- [X] use run(stringstream, ostream) on cg-mwesplit as lib
- [X] use run(stringstream, ostream) on vislcg3-grammar as lib
- [X] use run(stringstream, ostream) on divvun-suggest as lib
- [X] use upstream hfst ([[https://github.com/hfst/hfst/pull/352][merged]])
- [ ] use upstream vislcg3, currently [[https://github.com/TinoDidriksen/cg3/issues/1][waiting on a merge]] (updated: [[https://github.com/unhammer/vislcg3/tree/StreamApplicator-merge-r12311][StreamApplicator-merge-r12311]])
- [X] read xml pipeline specification and load data based on that
- [X] allow multiple pipelines in spec
- [ ] allow variants of one pipeline in spec (e.g. turn off section 1/2/3/â€¦ of grammarchecker.cg3)
- [X] allow similar metadata to hfst-ospell (see [[https://github.com/hfst/hfst-ospell/blob/master/tests/basic_test.xml][tests/basic_test.xml]])
- [X] load PipeSpec from char buffer
- [X] load TokenizerCmd from char buffer
- [X] load MweSplitCmd from char buffer
- [X] load CGCmd from char buffer
- [X] load SuggestCmd from char buffer (HFST needs an =HfstOlInputStream(std::istream&)=)
- [X] read zip-archive like zhfst
- [ ] get some API documentation
- [X] travis (both Mac and Ubuntu)


** TODO alternative suggestions on the same word

When we might have different error types, put the error tag on the
&SUGGEST reading:

#+begin_src cg
  "<dego>"
          "dego" CS <W:0> @CNP ID:11
  :
  "<lÃ¡vvomuorran>"
          "lÃ¡vvomuorra" N Sem/Dummytag Ess <W:0> @COMP-CS< &syn-not-dego R:DELETE1:11
          "lÃ¡vvomuorra" N Sem/Dummytag Nom <W:0> @COMP-CS< &syn-dego-nom &SUGGEST
  "<.>"
#+end_src

Here, /lÃ¡vvomuorran/ is the (only) word carrying error tags. A reading
on this word contains all info needed to generate the suggestion.

The reading with the &SUGGEST tag thus needs to have the error tag on
the same reading (otherwise we can't know which error tag-reading goes
with which DELETE/SUGGEST-reading).

-----

Do we ever want &SUGGEST on the same error instance (underline)
crossing at least two cohorts? In that case, we need e.g. R:RIGHT on
the rightmost word to be included in one and the same error instance:

#+begin_src cg
  "<grÃ¸nt>"
          "grÃ¸n" A Pst Sg Ind Neut ID:41
          "grÃ¸n" A Pst Sg Ind Masc &SUGGEST &sÃ¥-veldig-feil-masc R:RIGHT:42
          "grÃ¸n" A Pst Sg Def &SUGGEST &sÃ¥-veldig-feil-def
  :
  "<osten>"
          "ost" N Masc Sg Def ID:42
          "ost" N Masc Sg Ind &SUGGEST &sÃ¥-veldig-feil-masc
  "<.>"
#+end_src
Here, on seeing R:RIGHT, we know we need to underline until the next
word with the same error tag &sÃ¥-veldig-feil-masc, giving the
suggestion "grÃ¸n ost". Since a different suggestion was covered by
that underline, we have to expand the underline for that word as well
(giving "grÃ¸ne osten"), since UI's can't typically handle overlapping
underlines.
